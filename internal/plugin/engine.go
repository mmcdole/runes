package plugin

type BufferOutput struct {
	Line   string
	Buffer string
}

func NewPluginEngine() *PluginEngine {
	return &PluginEngine{
		InCommandChan:   make(chan string),
		InTextLineChan:  make(chan string),
		OutSendChan:     make(chan string),
		OutCommandChan:  make(chan string),
		OutTextLineChan: make(chan BufferOutput),
	}
}

type PluginEngine struct {
	// Receive command from a client
	// Note: check and execute aliases that match the input command
	InCommandChan chan string

	// Receive line of text from server
	// Note: check for actions/triggers, highlights, replacements, hides
	InTextLineChan chan string

	// Output commands that weren't handled by plugin engine
	// Note: forward commands to the server that weren't an alias
	OutCommandChan chan string

	// Output commands generated by the plugin engine
	// Note: calls to send() from plugins need to be processed from the start
	OutSendChan chan string

	// Output text line(s) to that have been processed
	// Note: forward text lines and plugin output to the client buffers
	OutTextLineChan chan BufferOutput
}

func (pe *PluginEngine) Start() {
	for {
		select {
		case command := <-pe.InCommandChan:
			pe.handleCommand(command)
		case line := <-pe.InTextLineChan:
			pe.handleTextLine(line)
		}
	}
}

func (pe *PluginEngine) handleCommand(command string) {
	// TODO: process commands and check against alias list
	pe.OutCommandChan <- command
}

func (pe *PluginEngine) handleTextLine(line string) {
	// TODO: process text line, check for actions/triggers/subs/highlights

	// Don't specify buffer to make it "default"
	pe.OutTextLineChan <- BufferOutput{Line: line}
}
